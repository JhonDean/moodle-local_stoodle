{"version":3,"file":"quiz.min.js","sources":["../src/quiz.js"],"sourcesContent":["export const init = () => {\n    const questionSet = JSON.parse(document.getElementById(\"question-set\").innerHTML);\n    const answerSet = JSON.parse(document.getElementById(\"answer-set\").innerHTML);\n    const questionDiv = document.querySelector(\".js-answer-area\");\n    const scoreArea = document.querySelector(\".score\");\n    const totalQuestions = Object.values(questionSet).length;\n\n    const quizMap = createQuizHash(questionSet, answerSet);\n    const questionTypes = declareQuestionTypes(questionSet, answerSet);\n\n    scoreArea.innerHTML = \"Score: 0 / \" + totalQuestions;\n    document.querySelector(\".submit-button\").addEventListener('click', () => {\n        questionValidation();\n    });\n\n    let index = 0;\n    for (const [key, value] of quizMap.entries()) {\n        const newDiv = document.createElement(\"div\");\n        newDiv.id = \"stoodle-div\";\n        const questionText = document.createElement(\"p\");\n        questionText.id = \"stoodle-question-text\";\n        questionText.textContent = \"Question \" + (index + 1) + \": \" + key;\n        newDiv.appendChild(questionText);\n\n        switch (questionTypes[index]) {\n            default:\n            case 0:\n                newDiv.id = \"open-response\";\n                createOpenResponseQuestion(newDiv, (\"option_\" + index));\n                break;\n            case 1:\n                newDiv.id = \"multiple-choice\";\n                for (const element in value[0]) {\n                    createInputNodeRadio(newDiv, (\"option_\" + index), index, getOptionAtIndex(quizMap, key, element));\n                }\n                break;\n            case 2:\n                newDiv.id = \"select-all\";\n                for (const element in value[0]) {\n                    createInputNodeCheckBox(newDiv, (\"option_\" + index), index, getOptionAtIndex(quizMap, key, element));\n                }\n                break;\n        }\n\n        questionDiv.appendChild(newDiv);\n        index++;\n    }\n\n    // Create questions and options\n    // for (const key in Object.values(questionSet)) {\n    //     const newDiv = document.createElement(\"div\");\n    //     newDiv.id = \"stoodle-div\";\n    //     const questionText = document.createElement(\"p\");\n    //     questionText.id = \"stoodle-question-text\";\n    //     questionText.textContent = \"Question \" + (parseInt(key) + 1) + \": \" + Object.values(questionSet)[key].question_text;\n    //     newDiv.appendChild(questionText);\n\n    //     // TO-DO: Explain the purpose of this switch statement\n    //     switch (questionTypes[key]) {\n    //         default:\n    //         case 0:\n    //             newDiv.id = \"open-response\";\n    //             createOpenResponseQuestion(newDiv, (\"option_\" + key));\n    //             break;\n    //         case 1:\n    //             newDiv.id = \"multiple-choice\";\n    //             for (const element in quizMap.get(Object.values(questionSet)[key].question_text)[0]) {\n    //                 const optionText = quizMap.get(Object.values(questionSet)[key].question_text)[0][element];\n    //                 createInputNodeRadio(newDiv, (\"option_\" + key), key, optionText);\n    //             }\n    //             break;\n    //         case 2:\n    //             newDiv.id = \"select-all\";\n    //             for (const element in quizMap.get(Object.values(questionSet)[key].question_text)[0]) {\n    //                 const optionText = quizMap.get(Object.values(questionSet)[key].question_text)[0][element];\n    //                 createInputNodeCheckBox(newDiv, (\"option_\" + key), key, optionText);\n    //             }\n    //             break;\n    //     }\n\n    //     questionDiv.appendChild(newDiv);\n    // }\n\n    /**\n     * Creates a open response question.\n     *\n     * @param {object} parent\n     * @param {string} name\n     */\n    function createOpenResponseQuestion(parent, name) {\n        const label = document.createElement(\"label\");\n        const textInput = document.createElement(\"textarea\");\n        textInput.id = name;\n        textInput.cols = 100;\n        label.appendChild(textInput);\n        parent.appendChild(label);\n    }\n\n    /**\n     * Creates a radio button.\n     *\n     * @param {object} parent\n     * @param {string} id\n     * @param {string} name\n     * @param {string} value\n     */\n    function createInputNodeRadio(parent, id, name, value) {\n        // Create a radio input\n        const radio = document.createElement(\"input\");\n        radio.type = \"radio\";\n        radio.id = id;\n        radio.name = name;\n        radio.value = value;\n\n        // Create the label to go with it\n        const label = document.createElement(\"label\");\n        label.appendChild(radio);\n        label.appendChild(document.createTextNode(value));\n\n        // Append them to the parent\n        parent.appendChild(label);\n        parent.appendChild(document.createElement(\"br\"));\n    }\n\n    /**\n     * Creates a checkbox button.\n     *\n     * @param {object} parent\n     * @param {string} id\n     * @param {string} name\n     * @param {string} value\n     */\n    function createInputNodeCheckBox(parent, id, name, value) {\n        // Create a radio input\n        const checkbox = document.createElement(\"input\");\n        checkbox.type = \"checkbox\";\n        checkbox.id = id;\n        checkbox.name = name;\n        checkbox.value = value;\n\n        // Create the label to go with it\n        const label = document.createElement(\"label\");\n        label.appendChild(checkbox);\n        label.appendChild(document.createTextNode(value));\n\n        // Append them to the parent\n        parent.appendChild(label);\n        parent.appendChild(document.createElement(\"br\"));\n    }\n\n    /**\n     * Validates the questions on the quiz. Checks if right or wrong.\n     *\n     */\n    function questionValidation() {\n        const correctIcon = \"\\u{2705}\";\n        const incorrectIcon = \"\\u{274C}\";\n        let numCorrect = 0;\n        let index = 0;\n\n        // TO-DO: Explain the purpose of this for-loop\n        for (const [key, value] of quizMap.entries()) {\n            const questionText = \"Question \" + (index + 1) + \": \" + key;\n\n            if (questionTypes[index] === 0) {\n                // Check Open Response\n                const option = document.getElementById(\"option_\" + index);\n                if (option.value === getAnswerAtIndex(quizMap, key, 0)) {\n                    window.console.log(\"Question \" + (index + 1) + \" is correct\");\n                    numCorrect++;\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + correctIcon;\n                } else {\n                    questionDiv.children[index].children[0].innerText = questionText + incorrectIcon + \" (manual review required)\";\n                }\n            } else if (questionTypes[index] === 1) {\n                // Check Multiple Choice\n                const option = document.querySelector('input[name= \"' + index + '\"]:checked');\n                if (option === null) {\n                    alert(\"Question \" + (index + 1) + \" is unanswered\");\n                    return;\n                }\n                if (getAnswerAtIndex(quizMap, key, 0) === option.value) {\n                    window.console.log(\"Question \" + (index + 1) + \" is correct\");\n                    numCorrect++;\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + correctIcon;\n                } else {\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + incorrectIcon;\n                }\n            } else if (questionTypes[index] === 2) {\n                // Check Select All\n                const option = document.querySelectorAll('input[name=\"' + index + '\"]:checked');\n                if (option.length < 1) {\n                    alert(\"Question \" + (index + 1) + \" is unanswered\");\n                    return;\n                }\n                let selectAllCorrectCounter = 0;\n                if (value[1].length !== option.length) {\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + incorrectIcon;\n                    continue;\n                }\n                for (let i = 0; i < value[1].length; i++) {\n                    if (getAnswerAtIndex(quizMap, key, i) === option[i].value) {\n                        selectAllCorrectCounter++;\n                    }\n                }\n                if (selectAllCorrectCounter === value[1].length) {\n                    numCorrect++;\n                    window.console.log(\"Question \" + (index + 1) + \" is correct\");\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + correctIcon;\n                } else {\n                    questionDiv.children[index].children[0].innerText = questionText + \" \" + incorrectIcon;\n                }\n            }\n            index++;\n        }\n\n        scoreArea.innerText = \"Score: \" + numCorrect + \" / \" + totalQuestions;\n    }\n\n    /**\n     * Returns an array with question types.\n     * 0 - Open Response,\n     * 1 - Multiple Choice,\n     * 2 - Select All\n     *\n     * @param {Object} questions\n     * @param {Object} options\n     * @return {Array} Resulting array with question types.\n     */\n    function declareQuestionTypes(questions, options) {\n        const questionTypesArray = new Array(Object.values(questions).length);\n        for (const questionKey in Object.values(questions)) {\n            const questionId = parseInt(Object.values(questions)[questionKey].id);\n            let count = 0;\n            for (const answerKey in Object.values(options)) {\n                const answerObject = Object.values(options)[answerKey];\n                if (parseInt(answerObject.stoodle_quiz_questionsid) === questionId && parseInt(answerObject.is_correct) === 1) {\n                    count++;\n                }\n            }\n            if (count > 1) {\n                questionTypesArray[questionKey] = 2;\n            } else if (count === 1 && parseInt(Object.values(questions)[questionKey].is_multiple_choice) === 1) {\n                questionTypesArray[questionKey] = 1;\n            } else {\n                questionTypesArray[questionKey] = 0;\n            }\n        }\n        return questionTypesArray;\n    }\n\n\n    /**\n     * Creates a Map by matching questions to their options in their respective sets.\n     * Consists of the question text as the key, and an array containing a set of all options and a set of correct options.\n     *\n     * @param {Object} qSet Set of all questions\n     * @param {Object} oSet Set of all options\n     * @return {Map} Resulting array\n     */\n    function createQuizHash(qSet, oSet) {\n        let resultSet = new Map();\n        for (const qKey in Object.values(qSet)) {\n            let optionArray = [];\n            let answerArray = [];\n            for (const oKey in Object.values(oSet)) {\n                const dbQuestionKey = parseInt(Object.values(qSet)[qKey].id);\n                const dbOptionKey = parseInt(Object.values(oSet)[oKey].stoodle_quiz_questionsid);\n                if (dbQuestionKey === dbOptionKey) {\n                    optionArray.push(Object.values(oSet)[oKey].option_text);\n                    if (parseInt(Object.values(oSet)[oKey].is_correct) === 1) {\n                        answerArray.push(Object.values(oSet)[oKey].option_text);\n                    }\n                }\n            }\n            resultSet.set(Object.values(qSet)[qKey].question_text, [optionArray, answerArray]);\n        }\n        return resultSet;\n    }\n\n    /**\n     * Getter for the array of all answer options in the quizMap.\n     *\n     * @param {Map} map The quiz map.\n     * @param {string} question The key for the map.\n     * @param {number} index The index of the option array.\n     */\n    function getOptionAtIndex(map, question, index) {\n        return map.get(question)[0][index];\n    }\n\n    /**\n     * Getter for the array of all answers in the quizMap.\n     *\n     * @param {Map} map The quiz map.\n     * @param {string} question The key for the map.\n     * @param {number} index The index of the option array.\n     */\n    function getAnswerAtIndex(map, question, index) {\n        return map.get(question)[1][index];\n    }\n};\n"],"names":["_exports","init","questionSet","JSON","parse","document","getElementById","innerHTML","answerSet","questionDiv","querySelector","scoreArea","totalQuestions","Object","values","length","quizMap","qSet","oSet","resultSet","Map","qKey","optionArray","answerArray","oKey","parseInt","id","stoodle_quiz_questionsid","push","option_text","is_correct","set","question_text","createQuizHash","questionTypes","questions","options","questionTypesArray","Array","questionKey","questionId","count","answerKey","answerObject","is_multiple_choice","declareQuestionTypes","addEventListener","correctIcon","incorrectIcon","numCorrect","index","key","value","entries","questionText","getAnswerAtIndex","window","console","log","children","innerText","option","alert","querySelectorAll","selectAllCorrectCounter","i","questionValidation","newDiv","createElement","textContent","appendChild","createOpenResponseQuestion","element","createInputNodeRadio","getOptionAtIndex","createInputNodeCheckBox","parent","name","label","textInput","cols","radio","type","createTextNode","checkbox","map","question","get"],"mappings":"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"}